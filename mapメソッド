mapメソッドの基本構文-->
配列.map { |変数| 実行する処理 }


# 実行する処理が複数行に渡る場合
配列.map do |変数|
  実行する処理
end
irb | mapメソッドの使用例
irb(main):001:0> numbers = [10, 20, 30, 40]
=> [10, 20, 30, 40]
irb(main):002:0> new_numbers= numbers.map { |n| n * 2 }
=> [20, 40, 60, 80]
irb(main):003:0> new_numbers
=> [20, 40, 60, 80]
mapメソッドは、配列だけではなくHashに対しても使用する事が出来る。返り値は、配列になる。



mapメソッドの基本的な使い方
mapメソッドの使い方は簡単です。
例えば、配列の要素を２倍にした新しい配列を作る場合は、下記の通りになる。

irb | 配列の要素を２倍にした新しい配列を作成する
irb(main):001:0> numbers = [10, 20, 30, 40]
=> [10, 20, 30, 40]
irb(main):002:0> new_numbers= numbers.map { |n| n * 2 }
=> [20, 40, 60, 80]
irb(main):003:0> new_numbers
=> [20, 40, 60, 80]
処理の流れ

まず、配列の最初の要素である10がブロック{}に渡されて変数nに代入
n*2(10*2)の結果が新しい配列に代入
この流れが配列の要素分ループ処理
新しい配列は、new_numbers変数に代入
参考: プロを目指す人のためのRuby入門(p96ページ参考)

eachメソッドをmapメソッドに置き換えて比較。
配列を扱うメソッドに使用頻度が高いeachメソッドがあるが、場合によってはmapメソッドで置き換えることが出来る。

先ほどのmapメソッドのコードをeachメソッドに置き換えると、下記の通り。

irb | mapメソッドをeachメソッドに置き換える
irb(main):004:0> numbers = [10, 20, 30, 40]
=> [10, 20, 30, 40]
irb(main):005:0> new_numbers = []
=> []
irb(main):006:0> numbers.each { |n| new_numbers << n*2 }
=> [10, 20, 30, 40]
irb(main):007:0>new_numbers
=> [20, 40, 60, 80]
eachメソッドを使うと、空配列new_numbersを用意して、ブロック内の処理結果を配列に入れなければならないので、コード量が少し増える。
さらに、ブロック内で、new_numbersに対して、<< n*2の処理も書いているので、冗長な書き方になる。

mapメソッドを使用するとブロック内では処理の本質のみが書かれているので非常に分かりやすい。

irb | 配列の要素を２倍にした新しい配列を作成する
irb(main):001:0> numbers = [10, 20, 30, 40]
=> [10, 20, 30, 40]
irb(main):002:0> new_numbers= numbers.map { |n| n * 2 }
=> [20, 40, 60, 80]
irb(main):003:0> new_numbers
=> [20, 40, 60, 80]
空の配列を用意して、他の配列を順番にループ処理をした結果を空の配列に入れる処理は、mapメソッドに置き換えることが出来る

このmapメソッドと同じ働きをするメソッドにcollectメソッドというものもある。

collectメソッド
collectメソッドは、mapメソッドと全く同じ動作をするメソッド。

irb | collectメソッドを使う場合
irb(main):009:0> numbers = [10, 20, 30, 40]
=> [10, 20, 30, 40]
irb(main):010:0>new_numbers= numbers.collect { |n| n * 2 }
=> [20, 40, 60, 80]
同じ動作のメソッドですが、名前の違いは発想の違いから来ている。
mapメソッド は、データ構造を保ったまま、あるルールに従い元のデータ構造を別データ構造に変換する発想です。
collect メソッドは、データ構造内の全ての要素に対して、ある処理を繰り返し実行し、その結果を集めたものという発想です。

異なる発想によって実装されたメソッドですが、動作は同じなので、どちらを使っても大丈夫です。
